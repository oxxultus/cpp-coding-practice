# 클래스와 객체
#### 객체에 대한 이해
```markdown
1. 실세계는 객체들의 집합이며 객체들이 상호 통신하는 시스템이다.
2. 캡슐화는 객체를 캡슐로 싸서 그 내부를 볼 수 없게 하고 외부의 접근으로부터 보호한다.
3. C++ 객체는 멤버 변수와 멤버 함수로 구성되며. 멤버 변수는 객체의 상태(state)을. 멤버 함수는 객체의 행동을 표현한다.
4. C++ 클래스는 객체를 정의하는 틀 혹은 설계도로서 사용자는 클래스로 새로운 데이터 타입을 선언한다.C++ 객체는 실행 중에 생성되어 존재하므로 실체(instance)라고도 부른다.
```
#### C++ 클래스 만들기
```markdown
1. class 키워드를 이용하여 클래스를 선언한다. 클래스 선언 뒤에는 반드시 세미콜론을 붙인다
2. 클래스는 선언부와 구현부로 나누어 작성하는 것이 원칙이다. 클래스 구현부는 클래스 선언부에 선언된 함수들의 코드를 구현하는 부분이다.
3. 객체의 멤버 접근은 '객체.멤버' 형식을 사용한다.
```
#### 생성자
```markdown
1. 생성자는 클래스의 이름과 동일한 멤버 함수로서 객체가 생성될 때 한 번만 실행되는 특별한 멤버이다.
2. 생성자는 객체의 초기화에 사용되며, 리턴 타입이 없고 중복이 가능하다.
3. 기본 생성자는 디폴트 생성자라고도 불리며 매개 변수 없는 생성자이다. 아무생성자도 선언되어 있지 않으면, 컴파일러가 기본생성자를 자동으로 삽입한다. 기본생성자는 단순 리턴한다.
```
#### 소멸자
```markdown
1. 소멸자는 객체가 소멸될 때 실행되는멤버함수로서 클래스의 이름앞에 ~를 붙인 이름으로 선언되어야 한다.
2. 소멸자는 매개변수를 가지지 않고 리턴 타입도 없으며, 중복이 불가능하다. 
3. 객체는 생성된 반대순으로 소멸된다.
```
#### 접근지정
```markdown
1. 접근 지정이란 객체를 캡슐화함에 따라 외부에서 접근가능한 멤버와 접근할 수 없는 멤버를 선언하는 지시이다.
2. 멤버의 접근 지정은 private, public, protected의 세가지가 있다.
3. private 멤버는 클래스 내부의 함수들만 접근할 수 있는 멤버이고, public 멤버는 클래스 내외의 무든 함수들이 접근할 수 있는 멤버이며, protected 멤버는 자식 클래스에서만 접근할 수 있는 멤버이다.
4. C++ 클래스의 디폴트 접근 지정은 private이므로 접근 지정이 생략되면 private로 처리 된다.
```
#### 인라인 함수
```markdown
1. 함수에 inline 키워드를 붙혀 인라인으로 선언하면, 컴파일러는 인라인 함수의 코드를 함수를 호출하는 곳에 확장시킨다. 그러므로 함수 호출이 일어나지 않고, 함수 호출에 대한 오버헤드를 제거하여 실행 속도를 높인다.
2. 인라인은 클래스의 멤버 함수나 외부 함수 모두 가능하며, 클래스 내의 선언부에 작성된 함수는 컴파일러에 의해 자동으로 인라인 처리 된다.
```

# 객체 포인터와 배열,  동적 생성
#### 객체 포인터
```markdown
1. C++에서는 객체의 주소를 가지는 객체 포인터를 선언하고 활용할 수 있다.
2. 객체 포인터로 객체의 멤버에 접근할 때 ->연산자를 사용한다.
3. 초기화 되지 않는 객체 포인터를 사용하면 null pointer assignment 실행 오류가 발생한다.
```
#### 객체  배열
```markdown
1. 객체 배열의 선언 및 활용 방법은 기본 타입 배열과 동일하다.
2. 객체 배열이 생성될 때 배열의 각 원소 객체마다 기본생성자가 실행되며, 배열이 소멸될 때 각 원소 객체마다 소멸자가 실행 된다. 원소 객체는 인덱스가 높은 곳에서 낮은 순으로 소멸된다.
```
#### 동적 메모리 할당 및 반환
```markdown
1. new 연산자로 동적 메모리를 할당 받고, delete 연산자로 할당받은 메모리를  반환한다.
2. new로 기본 타입의 배열을 할당 받고 delete로 소멸할 수 있다.
3. new와 delete는 기본연산자 이다.
```
#### 객체와 객체 배열의 동적 생성 및 반환
```markdown
1. new 와 delete를 이용하여 객체를 할당 받고 반환할 때 생성자와 소멸자가 각각 실행된다.
2. new와 delete를 이용하여 객체 배열을 할당 받고 반활할 수 있으며, 이때 배열의 각 객체마다 생성자와 소멸자가 실행되고, 소멸자는 생성된 반대순으로 실행된다.
3. new로 객체 배열을 생성할 때는 기본 생성자가 호출된다.
4. new로 할당 받은 메모리는 실행 중에 delete를 이용하여 반환하지 않는 한 시스템에 반환 되지 않는다. 동적으로 할당 받은 메모리에 대한 주소를 잃어버리게 되면, 메모리 누수가 발생한다. 프로그램이 종료하면 동적으로 할당 받은 메모리는 자동 반환 된다.
```
#### this 포인터
```markdown
1. this는 객체 자신에 대한 포인터이다.
2. 객체의 멤버 함수가 호출될 때 컴파일러는 객체의 주소를 멤버 함수에 묵시적으로 전달하며, this는 이 주소를 받도록 컴파일러에 의해 몰래 삽입된 매개 변수의 이름이다.
3. 클래스의 non-static멤버 함수에서만 사용할 수 있다.
```
#### string 클래스를 이용한 문자열 사용
```markdown
1. string 클래스는 C++표준 라이브러리에 포함된 것으로 문자열을 다루는 클래스이다. 
2. string 클래스는 문자열의 길이에 따라 문자열을 저장하는 내부 메모리의 크기를 자동으로 조절하므로 사용하기 편리하고, 문자열 조작을 위한 많은 멤버 함수와 연산자 함수를 제공한다.
3. 문자열을 키보드로부터 입력 받기 위해 string헤더 파일에 선언된 getline() 전역 함수를 이용하면, 공백 문자를 포함하는 문자열을 입력받을 수 있다.
4. stoi() 함수를 이용하면 문자열을 숫자로 변환할 수 있다.
```
# 함수와 참조, 복사 생성자
#### C++ 인자 전달 방식
```markdown
 1. 값에 의한 호출, 주소에 의한 호출, 참조에 의한 호출 의 3가지가 있다.
 2. 값에 의한 호출 시 실인자의 값이 매개변수에 복사 되어 전달되므로, 매개 변수와 실인자는 메모리를 서로 공유 하지 않는다. 그로므로 함수 내에서 매개 변수의 값을 변경해도 실인자의 값이 바뀌지 않는다. 객체가 값에의한 호출로 전달되면 매개 변수 객체의 생성자는 실행되지 않고 소멸자만 실행 되는 문제가 발생한다.
 3. 참조에 의한 호출 은 원본에 대한 참조만 전달되므로 함수 내에서 참조 매개변수를 이용하여 원본 데이터를 읽고 수정할 수 있다.
```
#### 객체 치환 및 객체 리턴
```markdown
1. 치환 연산자로 객체를 치환하면, 비트 단위로 객체가 복사된다.
2. C++ 함수는 객체를 리턴할 수 있다. 이때 객체의 복사본이 만들어져 리턴된다.
```

#### 참조와 함수
```markdown
1. 참조란 가리킨다 란 뜻이며, 참조 변수는 이미 존재하는 변수에 붙여진 별명이다
2. 참조 변수의 선언으로 변수 이름만 생기고 변수 공간이 할당되지 않는다.
3. 참조는 포인터가 아니며, C++뿐 아니라 PASCAL등 다른 언어에도 있다.
4. 참조 변수는 참조자(&)를 사용하여 선언되며, 반드시 기존 변수로 초기화 되어야 한다.
5. 참조 타입의 매개 변수를 가진 함수에 대한 호출을 참조에 의한 호출 이라고 부른다
6. C++에서 참조를 리턴하는 함수를 작성할 수 있다.
```
#### 깊은 복사 얕은 복사
```markdown
1. 복사에는 얕은 복사와 깊은 복사의 두 종류가 있다. 얕은 복사는 객체의 멤버를 1:1로 단순 복사하지만. 깊은 복사는 객체의 멤버 포인터가 할당 받은 메모리까지 복사하는 완전한 형태의 복사이다.
2. 복사 생성은 객체를 생성할 때 원본 객체를 복사하여 생성하는 것을 말한다.
3. 묵시적으로 복사 생성이 일어나는 경우는 다음 3가지이다.
	SampleClass s = y; 			//객체 x 가 y로 초기화 되어 생성
	void f(SampleClass x){} 	//함수 f()가 호출되어 객체  x가 생길 때
	SampleClass f() {SampleClass x; return x;} //함수가 객체를 리턴할 때
```
#### 복사 생성자
```markdown
1. 복사 생성자는 객체의 복사 생성 시에 호출 되는 특별한 원형의 생성자로서, 하나의 매개변수만을 가지며, 매개 변수는 클래스에 대한 참조 타입이다.
2. 복사 생성자가 작성되지 않은 클래스의 경우 컴파일러가 디폴트 복사 생성자를 자동 삽입하며, 디폴트 복사 생성자는 앝은 복사를 실행한다.
3. 클래스에 포인터 변수 멤버가 있는 경우, 디폴트 복사 생성자와 같이 얕은 복사 생성자를 사용하면 포인터가 가진 메모리를 원본과 사본 객체가 공유하는 문제가 생기고, 프로그렘이 비정상 종료되기도 하므로 깊은 복사 생성자를 반드시 작성하는 것이 좋다.
```

# 함수 중복과 static 멤버
#### 함수 중복
```markdown
1. C++에서는 같은 이름의 함수를 여러 개 작성할 수 있는 함수 중복을 지원한다.
2. 함수 중복이 성공하기 위해서는 중복된 함수들의 이름이 같아야 하고, 이들의 매개 변수 타입이나 개수가 달라야 한다.
3. 함수 중복과 중복된 함수에 대한 호출은 모두 컴파일러에 의해 처리된다.
4. 소멸자는 매개변수를 가지지 않기 때문에 함수 중복이 없다.
5. 생성자 함수 중복을 통해 객체를 생성하는 방법을 다양화 한다.
```

#### 디폴트 매개 변수
```markdown
1. 디폴트 매개 변수란 함수의 호출문에서 매개변수에 값을 전달하지 않는 경우, 디폴트 값으로 설정된 값을 받도록 선언된 매개 변수 이다.
2. 디폴트 매개 변수를 이용하면 중복된 함수들을 하나의 함수로 작성할 수 있다.
3. 디폴트 매개 변수는 보통 매개 변수가 모두 선언된 뒤에 선언되어야 한다.
```

#### 함수 중복의 모호성
```markdown
1. 중복된 함수를 호출하는 경우, 호출문이 어떤 함수를 호출하는지 컴파일러가 처리하지 못하는 모호한 경우가 있다.
2. 형 변환으로 인한 모호성, 참조 매개 변수로 인한 모호성, 디폴트 매개 변수로 인한 모호성 등이 있다.
```

#### static 멤버
```markdown
1. static 멤버는 멤버 선언 시 static 지정자로 선언한다.
2. static 멤버는 객체의 생성과 상관없이 프로그렘이 시작할 때 생성되고, 프로그렘이 종료할 때 소멸된다.
3. static 멤버는 한 클래스에 하나만 생성되므로 클래스 멤버라고도 부르며, 클래스의 모든 객체들에 의해 공유된다.
4. non-static 멤버는 static 멤버가 아닌 보통 멤버로서, 클래스의 객체가 생성될 때 객체 내에 생성되고 객체가 소멸할 때 함께 소멸 된다.
5. static 멤버 함수는 static 멤버 함수나 변수만 접근할 수 있으며, non-static 멤버를 접근할 수 없다. 함수 내의 지역 변수를 접근하는 것은 문제없다.
6. non-static 멤버 함수는 static 멤버나 non-static 멤버 모두 정상적으로 접근 가능하다.
7. static 멤버 함수는 함수의 코드 내에서 this를 사용할 수 없다.
8. static 멤버를 접근하는 방법은 다음 세 가지가 있다.
	객체이름.static멤버
	객체포인터->static멤버 
	클래스명::static멤버
9. static 멤버 변수에 대해, 반드시 클래스 바깥에 static 멤버 변수의 메모리를 할당하는 전역 변수 선언문을 작성해야 한다.
	int Person::sharedMoney = 10; //sharedMoney가 Person class에 static으로 선언되어 있음
전역 변수나 전역 함수는 static을 사용하여 클래스로 캡슐화 할 수 있으며, static멤버 변수는 개체 사이에 공유 변수로 활용된다
```
# 프렌드와 연산자 중복
